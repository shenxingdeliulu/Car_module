2014.11
小车方向控制一共分为两部分
	第一部分：产生pwm，一共有两种方式，分为pwm硬件输出和软件延时输出，硬件输出的pwm我打算用于舵机的控制上，写了一个驱动，放在/homg/wang/work/modules/pwm中，.c是原码，生成的.ko也在里面，软件延时用于控制小车的速度，分别写了两个驱动来分别控制两个轮子（为什么不写在一起？写在一起有一个不产生波形，待改进）原码分别位于modules的pwm_2和pwm_22中
	第二部分：小车动起来的方向我写在了car_move目录下内有原码和.ko分别，能够让小车前进后退左转右转
	小车tcp协议部分原码位于modules下的tcp_ctl文件中，有原码！


最后综合的能够通过tcp控制小车我会放在modules下的tcp_car中！！！

2014.11.12日更新
由于分开两个pwm驱动，在应用程序中无论在一个线程还是两个线程中，由于线程调度的先后，导致在死循环中，udelay的延时虽然没变，但是总体的周期却变为了原来的两倍，所以占空比无法超过50%，所以我尝试将两个pwm合为一个驱动，原码在pwm_2中的delay。c中 case 1将两个io口同时之高和之地然后进行延时，这样就避免了在死循环中周期加倍的问题，但是带来的问题是无法分别调整两个轮子的速度，只能让两个轮子共速，解决如下:
在tcp_ctl 中的.c和makefile是用来控制小车前后左右并且两个轮子共速的程序，之所以能够共速是因为我将pwm的驱动修改了，原码仍在pwm_2文件夹中，case 1是共速的情况，case 3 和case4 是一组，想法是让一边的轮子pwm一直高电平，这样这边的轮子就一直最高速，另外一边给延时，这样就能调整这边的占空比从而调节这边的速度，因此能够产生一个差速从而改变航向（针对车子，如果是船的话还需要加上舵机），case 5 case6是反之
能够实现上面的差速程序在 tcp_ctl中的tcp_ctl_div中，只是实验性质，出来的现象是一边高速一边可调速，为以后电子罗盘自动调整航向做好准备

在板子上的/opt/tcp_ctl/test下的文件是共速前后左右方向可调原码在虚拟机/home/wang/work/mod
ules/tcp_ctl/tcp_iopwm.c

在/opt/tcp_ctl/test2下的文件是实验左右差速的文件，原码在虚拟机/home/wang/work/modules/tcp_ctl/tcp_ctl_div/tcp_iopwm.c

